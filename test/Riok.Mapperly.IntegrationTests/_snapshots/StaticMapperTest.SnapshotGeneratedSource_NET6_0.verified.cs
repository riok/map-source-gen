// <auto-generated />
#nullable enable
namespace Riok.Mapperly.IntegrationTests.Mapper
{
    public static partial class StaticTestMapper
    {
        public static partial int DirectInt(int value)
        {
            return value;
        }

        public static partial int? DirectIntNullable(int? value)
        {
            return value == null ? default(int?) : value.Value;
        }

        public static partial long ImplicitCastInt(int value)
        {
            return (long)value;
        }

        public static partial int ExplicitCastInt(uint value)
        {
            return (int)value;
        }

        public static partial int? CastIntNullable(int value)
        {
            return (int?)value;
        }

        public static partial global::System.Guid ParseableGuid(string id)
        {
            return global::System.Guid.Parse(id);
        }

        public static partial int ParseableInt(string value)
        {
            return int.Parse(value);
        }

        public static partial global::System.DateTime DirectDateTime(global::System.DateTime dateTime)
        {
            return dateTime;
        }

        public static partial global::System.Collections.Generic.IEnumerable<global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto> MapAllDtos(global::System.Collections.Generic.IEnumerable<global::Riok.Mapperly.IntegrationTests.Models.TestObject> objects)
        {
            return global::System.Linq.Enumerable.Select(objects, x => MapToDtoExt(x));
        }

        public static partial global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto MapToDtoExt(this global::Riok.Mapperly.IntegrationTests.Models.TestObject src)
        {
            var target = new global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto(DirectInt(src.CtorValue), ctorValue2: DirectInt(src.CtorValue2))
            {
                IntInitOnlyValue = DirectInt(src.IntInitOnlyValue),
                RequiredValue = DirectInt(src.RequiredValue),
            };
            if (src.NullableFlattening is { } srcNullableFlattening)
            {
                target.NullableFlatteningIdValue = CastIntNullable(srcNullableFlattening.IdValue);
            }
            if (src.NestedNullable is { } srcNestedNullable)
            {
                target.NestedNullableIntValue = DirectInt(srcNestedNullable.IntValue);
                target.NestedNullable = MapToTestObjectNestedDto(srcNestedNullable);
            }
            if (src.NestedNullableTargetNotNullable is { } srcNestedNullableTargetNotNullable)
            {
                target.NestedNullableTargetNotNullable = MapToTestObjectNestedDto(srcNestedNullableTargetNotNullable);
            }
            if (src.StringNullableTargetNotNullable is { } srcStringNullableTargetNotNullable)
            {
                target.StringNullableTargetNotNullable = srcStringNullableTargetNotNullable;
            }
            if (src.TupleValue is { } srcTupleValue)
            {
                target.TupleValue = MapToValueTuple(srcTupleValue);
            }
            if (src.RecursiveObject is { } srcRecursiveObject)
            {
                target.RecursiveObject = MapToDtoExt(srcRecursiveObject);
            }
            if (src.NullableReadOnlyObjectCollection is { } srcNullableReadOnlyObjectCollection)
            {
                target.NullableReadOnlyObjectCollection = MapToTestObjectNestedDtoArray(srcNullableReadOnlyObjectCollection);
            }
            if (src.SubObject is { } srcSubObject)
            {
                target.SubObject = MapToInheritanceSubObjectDto(srcSubObject);
            }
            target.IntValue = DirectInt(src.IntValue);
            target.StringValue = src.StringValue;
            target.FlatteningIdValue = DirectInt(src.Flattening.IdValue);
            target.SourceTargetSameObjectType = src.SourceTargetSameObjectType;
            target.SpanValue = MapToInt32Array(src.SpanValue);
            target.MemoryValue = MapToInt32Array1(src.MemoryValue.Span);
            target.StackValue = new global::System.Collections.Generic.Stack<int>(global::System.Linq.Enumerable.Select(src.StackValue, x => ParseableInt(x)));
            target.QueueValue = new global::System.Collections.Generic.Queue<int>(global::System.Linq.Enumerable.Select(src.QueueValue, x => ParseableInt(x)));
            target.ImmutableArrayValue = global::System.Collections.Immutable.ImmutableArray.ToImmutableArray(global::System.Linq.Enumerable.Select(src.ImmutableArrayValue, x => ParseableInt(x)));
            target.ImmutableListValue = global::System.Collections.Immutable.ImmutableList.ToImmutableList(global::System.Linq.Enumerable.Select(src.ImmutableListValue, x => ParseableInt(x)));
            target.ImmutableHashSetValue = global::System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet(global::System.Linq.Enumerable.Select(src.ImmutableHashSetValue, x => ParseableInt(x)));
            target.ImmutableQueueValue = global::System.Collections.Immutable.ImmutableQueue.CreateRange(global::System.Linq.Enumerable.Select(src.ImmutableQueueValue, x => ParseableInt(x)));
            target.ImmutableStackValue = global::System.Collections.Immutable.ImmutableStack.CreateRange(global::System.Linq.Enumerable.Select(src.ImmutableStackValue, x => ParseableInt(x)));
            target.ImmutableSortedSetValue = global::System.Collections.Immutable.ImmutableSortedSet.ToImmutableSortedSet(global::System.Linq.Enumerable.Select(src.ImmutableSortedSetValue, x => ParseableInt(x)));
            target.ImmutableDictionaryValue = global::System.Collections.Immutable.ImmutableDictionary.ToImmutableDictionary(src.ImmutableDictionaryValue, x => ParseableInt(x.Key), x => ParseableInt(x.Value));
            target.ImmutableSortedDictionaryValue = global::System.Collections.Immutable.ImmutableSortedDictionary.ToImmutableSortedDictionary(src.ImmutableSortedDictionaryValue, x => ParseableInt(x.Key), x => ParseableInt(x.Value));
            foreach (var item in src.ExistingISet)
            {
                target.ExistingISet.Add(ParseableInt(item));
            }
            target.ExistingHashSet.EnsureCapacity(src.ExistingHashSet.Count + target.ExistingHashSet.Count);
            foreach (var item1 in src.ExistingHashSet)
            {
                target.ExistingHashSet.Add(ParseableInt(item1));
            }
            foreach (var item2 in src.ExistingSortedSet)
            {
                target.ExistingSortedSet.Add(ParseableInt(item2));
            }
            MapExistingList(src.ExistingList, target.ExistingList);
            target.ISet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(src.ISet, x => ParseableInt(x)));
            target.IReadOnlySet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(src.IReadOnlySet, x => ParseableInt(x)));
            target.HashSet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(src.HashSet, x => ParseableInt(x)));
            target.SortedSet = new global::System.Collections.Generic.SortedSet<int>(global::System.Linq.Enumerable.Select(src.SortedSet, x => ParseableInt(x)));
            target.EnumValue = (global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue)src.EnumValue;
            target.FlagsEnumValue = (global::Riok.Mapperly.IntegrationTests.Dto.TestFlagsEnumDto)src.FlagsEnumValue;
            target.EnumName = MapToEnumDtoByName(src.EnumName);
            target.EnumRawValue = (byte)src.EnumRawValue;
            target.EnumStringValue = MapToString(src.EnumStringValue);
            target.EnumReverseStringValue = MapToTestEnumDtoByValue(src.EnumReverseStringValue);
            target.DateTimeValueTargetDateOnly = global::System.DateOnly.FromDateTime(src.DateTimeValueTargetDateOnly);
            target.DateTimeValueTargetTimeOnly = global::System.TimeOnly.FromDateTime(src.DateTimeValueTargetTimeOnly);
            return target;
        }

        private static partial global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto MapToDtoInternal(global::Riok.Mapperly.IntegrationTests.Models.TestObject testObject)
        {
            var target = new global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto(DirectInt(testObject.CtorValue), ctorValue2: DirectInt(testObject.CtorValue2))
            {
                IntInitOnlyValue = DirectInt(testObject.IntInitOnlyValue),
                RequiredValue = DirectInt(testObject.RequiredValue),
            };
            if (testObject.NullableFlattening is { } testObjectNullableFlattening)
            {
                target.NullableFlatteningIdValue = CastIntNullable(testObjectNullableFlattening.IdValue);
            }
            if (testObject.NullableUnflatteningIdValue is { } testObjectNullableUnflatteningIdValue)
            {
                target.NullableUnflattening ??= new();
                target.NullableUnflattening.IdValue = DirectInt(testObjectNullableUnflatteningIdValue);
            }
            if (testObject.NestedNullable is { } testObjectNestedNullable)
            {
                target.NestedNullableIntValue = DirectInt(testObjectNestedNullable.IntValue);
                target.NestedNullable = MapToTestObjectNestedDto(testObjectNestedNullable);
            }
            if (testObject.NestedNullableTargetNotNullable is { } testObjectNestedNullableTargetNotNullable)
            {
                target.NestedNullableTargetNotNullable = MapToTestObjectNestedDto(testObjectNestedNullableTargetNotNullable);
            }
            if (testObject.StringNullableTargetNotNullable is { } testObjectStringNullableTargetNotNullable)
            {
                target.StringNullableTargetNotNullable = testObjectStringNullableTargetNotNullable;
            }
            if (testObject.TupleValue is { } testObjectTupleValue)
            {
                target.TupleValue = MapToValueTuple(testObjectTupleValue);
            }
            if (testObject.RecursiveObject is { } testObjectRecursiveObject)
            {
                target.RecursiveObject = MapToDtoExt(testObjectRecursiveObject);
            }
            if (testObject.NullableReadOnlyObjectCollection is { } testObjectNullableReadOnlyObjectCollection)
            {
                target.NullableReadOnlyObjectCollection = MapToTestObjectNestedDtoArray(testObjectNullableReadOnlyObjectCollection);
            }
            if (testObject.SubObject is { } testObjectSubObject)
            {
                target.SubObject = MapToInheritanceSubObjectDto(testObjectSubObject);
            }
            target.IntValue = DirectInt(testObject.IntValue);
            target.StringValue = testObject.StringValue;
            target.RenamedStringValue2 = testObject.RenamedStringValue;
            target.FlatteningIdValue = DirectInt(testObject.Flattening.IdValue);
            target.Unflattening.IdValue = DirectInt(testObject.UnflatteningIdValue);
            target.SourceTargetSameObjectType = testObject.SourceTargetSameObjectType;
            target.SpanValue = MapToInt32Array(testObject.SpanValue);
            target.MemoryValue = MapToInt32Array1(testObject.MemoryValue.Span);
            target.StackValue = new global::System.Collections.Generic.Stack<int>(global::System.Linq.Enumerable.Select(testObject.StackValue, x => ParseableInt(x)));
            target.QueueValue = new global::System.Collections.Generic.Queue<int>(global::System.Linq.Enumerable.Select(testObject.QueueValue, x => ParseableInt(x)));
            target.ImmutableArrayValue = global::System.Collections.Immutable.ImmutableArray.ToImmutableArray(global::System.Linq.Enumerable.Select(testObject.ImmutableArrayValue, x => ParseableInt(x)));
            target.ImmutableListValue = global::System.Collections.Immutable.ImmutableList.ToImmutableList(global::System.Linq.Enumerable.Select(testObject.ImmutableListValue, x => ParseableInt(x)));
            target.ImmutableHashSetValue = global::System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet(global::System.Linq.Enumerable.Select(testObject.ImmutableHashSetValue, x => ParseableInt(x)));
            target.ImmutableQueueValue = global::System.Collections.Immutable.ImmutableQueue.CreateRange(global::System.Linq.Enumerable.Select(testObject.ImmutableQueueValue, x => ParseableInt(x)));
            target.ImmutableStackValue = global::System.Collections.Immutable.ImmutableStack.CreateRange(global::System.Linq.Enumerable.Select(testObject.ImmutableStackValue, x => ParseableInt(x)));
            target.ImmutableSortedSetValue = global::System.Collections.Immutable.ImmutableSortedSet.ToImmutableSortedSet(global::System.Linq.Enumerable.Select(testObject.ImmutableSortedSetValue, x => ParseableInt(x)));
            target.ImmutableDictionaryValue = global::System.Collections.Immutable.ImmutableDictionary.ToImmutableDictionary(testObject.ImmutableDictionaryValue, x => ParseableInt(x.Key), x => ParseableInt(x.Value));
            target.ImmutableSortedDictionaryValue = global::System.Collections.Immutable.ImmutableSortedDictionary.ToImmutableSortedDictionary(testObject.ImmutableSortedDictionaryValue, x => ParseableInt(x.Key), x => ParseableInt(x.Value));
            foreach (var item in testObject.ExistingISet)
            {
                target.ExistingISet.Add(ParseableInt(item));
            }
            target.ExistingHashSet.EnsureCapacity(testObject.ExistingHashSet.Count + target.ExistingHashSet.Count);
            foreach (var item1 in testObject.ExistingHashSet)
            {
                target.ExistingHashSet.Add(ParseableInt(item1));
            }
            foreach (var item2 in testObject.ExistingSortedSet)
            {
                target.ExistingSortedSet.Add(ParseableInt(item2));
            }
            MapExistingList(testObject.ExistingList, target.ExistingList);
            target.ISet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(testObject.ISet, x => ParseableInt(x)));
            target.IReadOnlySet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(testObject.IReadOnlySet, x => ParseableInt(x)));
            target.HashSet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(testObject.HashSet, x => ParseableInt(x)));
            target.SortedSet = new global::System.Collections.Generic.SortedSet<int>(global::System.Linq.Enumerable.Select(testObject.SortedSet, x => ParseableInt(x)));
            target.EnumValue = (global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue)testObject.EnumValue;
            target.FlagsEnumValue = (global::Riok.Mapperly.IntegrationTests.Dto.TestFlagsEnumDto)testObject.FlagsEnumValue;
            target.EnumName = MapToEnumDtoByName(testObject.EnumName);
            target.EnumRawValue = (byte)testObject.EnumRawValue;
            target.EnumStringValue = MapToString(testObject.EnumStringValue);
            target.EnumReverseStringValue = MapToTestEnumDtoByValue(testObject.EnumReverseStringValue);
            target.DateTimeValueTargetDateOnly = global::System.DateOnly.FromDateTime(testObject.DateTimeValueTargetDateOnly);
            target.DateTimeValueTargetTimeOnly = global::System.TimeOnly.FromDateTime(testObject.DateTimeValueTargetTimeOnly);
            return target;
        }

        public static partial global::Riok.Mapperly.IntegrationTests.Models.TestObject MapFromDto(global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto dto)
        {
            var target = new global::Riok.Mapperly.IntegrationTests.Models.TestObject(DirectInt(dto.CtorValue), ctorValue2: DirectInt(dto.CtorValue2))
            {
                IntInitOnlyValue = DirectInt(dto.IntInitOnlyValue),
                RequiredValue = DirectInt(dto.RequiredValue),
            };
            if (dto.NullableUnflattening is { } dtoNullableUnflattening)
            {
                target.NullableUnflatteningIdValue = CastIntNullable(dtoNullableUnflattening.IdValue);
            }
            if (dto.NestedNullable is { } dtoNestedNullable)
            {
                target.NestedNullable = MapToTestObjectNested(dtoNestedNullable);
            }
            if (dto.TupleValue is { } dtoTupleValue)
            {
                target.TupleValue = MapToValueTuple1(dtoTupleValue);
            }
            if (dto.RecursiveObject is { } dtoRecursiveObject)
            {
                target.RecursiveObject = MapFromDto(dtoRecursiveObject);
            }
            if (dto.NullableReadOnlyObjectCollection is { } dtoNullableReadOnlyObjectCollection)
            {
                target.NullableReadOnlyObjectCollection = MapToIReadOnlyCollection(dtoNullableReadOnlyObjectCollection);
            }
            if (dto.SubObject is { } dtoSubObject)
            {
                target.SubObject = MapToInheritanceSubObject(dtoSubObject);
            }
            target.IntValue = DirectInt(dto.IntValue);
            target.StringValue = dto.StringValue;
            target.UnflatteningIdValue = DirectInt(dto.Unflattening.IdValue);
            target.NestedNullableTargetNotNullable = MapToTestObjectNested(dto.NestedNullableTargetNotNullable);
            target.StringNullableTargetNotNullable = dto.StringNullableTargetNotNullable;
            target.SourceTargetSameObjectType = dto.SourceTargetSameObjectType;
            target.MemoryValue = MapToStringArray(dto.MemoryValue.Span);
            target.StackValue = new global::System.Collections.Generic.Stack<string>(global::System.Linq.Enumerable.Select(dto.StackValue, x => x.ToString()));
            target.QueueValue = new global::System.Collections.Generic.Queue<string>(global::System.Linq.Enumerable.Select(dto.QueueValue, x => x.ToString()));
            target.ImmutableArrayValue = global::System.Collections.Immutable.ImmutableArray.ToImmutableArray(global::System.Linq.Enumerable.Select(dto.ImmutableArrayValue, x => x.ToString()));
            target.ImmutableListValue = global::System.Collections.Immutable.ImmutableList.ToImmutableList(global::System.Linq.Enumerable.Select(dto.ImmutableListValue, x => x.ToString()));
            target.ImmutableHashSetValue = global::System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet(global::System.Linq.Enumerable.Select(dto.ImmutableHashSetValue, x => x.ToString()));
            target.ImmutableQueueValue = global::System.Collections.Immutable.ImmutableQueue.CreateRange(global::System.Linq.Enumerable.Select(dto.ImmutableQueueValue, x => x.ToString()));
            target.ImmutableStackValue = global::System.Collections.Immutable.ImmutableStack.CreateRange(global::System.Linq.Enumerable.Select(dto.ImmutableStackValue, x => x.ToString()));
            target.ImmutableSortedSetValue = global::System.Collections.Immutable.ImmutableSortedSet.ToImmutableSortedSet(global::System.Linq.Enumerable.Select(dto.ImmutableSortedSetValue, x => x.ToString()));
            target.ImmutableDictionaryValue = global::System.Collections.Immutable.ImmutableDictionary.ToImmutableDictionary(dto.ImmutableDictionaryValue, x => x.Key.ToString(), x => x.Value.ToString());
            target.ImmutableSortedDictionaryValue = global::System.Collections.Immutable.ImmutableSortedDictionary.ToImmutableSortedDictionary(dto.ImmutableSortedDictionaryValue, x => x.Key.ToString(), x => x.Value.ToString());
            foreach (var item in dto.ExistingISet)
            {
                target.ExistingISet.Add(item.ToString());
            }
            target.ExistingHashSet.EnsureCapacity(dto.ExistingHashSet.Count + target.ExistingHashSet.Count);
            foreach (var item1 in dto.ExistingHashSet)
            {
                target.ExistingHashSet.Add(item1.ToString());
            }
            foreach (var item2 in dto.ExistingSortedSet)
            {
                target.ExistingSortedSet.Add(item2.ToString());
            }
            target.ExistingList.EnsureCapacity(dto.ExistingList.Count + target.ExistingList.Count);
            foreach (var item3 in dto.ExistingList)
            {
                target.ExistingList.Add(item3.ToString());
            }
            target.ISet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(dto.ISet, x => x.ToString()));
            target.IReadOnlySet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(dto.IReadOnlySet, x => x.ToString()));
            target.HashSet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(dto.HashSet, x => x.ToString()));
            target.SortedSet = new global::System.Collections.Generic.SortedSet<string>(global::System.Linq.Enumerable.Select(dto.SortedSet, x => x.ToString()));
            target.EnumValue = MapToEnumByValueCheckDefined(dto.EnumValue);
            target.FlagsEnumValue = MapToFlagsEnumByValueCheckDefined(dto.FlagsEnumValue);
            target.EnumName = MapToEnumByNameWithFallback(dto.EnumName);
            target.EnumRawValue = (global::Riok.Mapperly.IntegrationTests.Models.TestEnum)dto.EnumRawValue;
            target.EnumStringValue = MapToTestEnum(dto.EnumStringValue);
            target.EnumReverseStringValue = MapToString1(dto.EnumReverseStringValue);
            return target;
        }

        public static partial void UpdateDto(global::Riok.Mapperly.IntegrationTests.Models.TestObject source, global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto target)
        {
            if (source.NullableFlattening is { } sourceNullableFlattening)
            {
                target.NullableFlatteningIdValue = CastIntNullable(sourceNullableFlattening.IdValue);
            }
            if (source.NestedNullable is { } sourceNestedNullable)
            {
                target.NestedNullableIntValue = DirectInt(sourceNestedNullable.IntValue);
                target.NestedNullable = MapToTestObjectNestedDto(sourceNestedNullable);
            }
            if (source.NestedNullableTargetNotNullable is { } sourceNestedNullableTargetNotNullable)
            {
                target.NestedNullableTargetNotNullable = MapToTestObjectNestedDto(sourceNestedNullableTargetNotNullable);
            }
            if (source.StringNullableTargetNotNullable is { } sourceStringNullableTargetNotNullable)
            {
                target.StringNullableTargetNotNullable = sourceStringNullableTargetNotNullable;
            }
            if (source.TupleValue is { } sourceTupleValue)
            {
                target.TupleValue = MapToValueTuple(sourceTupleValue);
            }
            if (source.RecursiveObject is { } sourceRecursiveObject)
            {
                target.RecursiveObject = MapToDtoExt(sourceRecursiveObject);
            }
            if (source.NullableReadOnlyObjectCollection is { } sourceNullableReadOnlyObjectCollection)
            {
                target.NullableReadOnlyObjectCollection = MapToTestObjectNestedDtoArray(sourceNullableReadOnlyObjectCollection);
            }
            if (source.SubObject is { } sourceSubObject)
            {
                target.SubObject = MapToInheritanceSubObjectDto(sourceSubObject);
            }
            target.CtorValue = DirectInt(source.CtorValue);
            target.CtorValue2 = DirectInt(source.CtorValue2);
            target.IntValue = DirectInt(source.IntValue);
            target.StringValue = source.StringValue;
            target.FlatteningIdValue = DirectInt(source.Flattening.IdValue);
            target.SourceTargetSameObjectType = source.SourceTargetSameObjectType;
            target.SpanValue = MapToInt32Array(source.SpanValue);
            target.MemoryValue = MapToInt32Array1(source.MemoryValue.Span);
            target.StackValue = new global::System.Collections.Generic.Stack<int>(global::System.Linq.Enumerable.Select(source.StackValue, x => ParseableInt(x)));
            target.QueueValue = new global::System.Collections.Generic.Queue<int>(global::System.Linq.Enumerable.Select(source.QueueValue, x => ParseableInt(x)));
            target.ImmutableArrayValue = global::System.Collections.Immutable.ImmutableArray.ToImmutableArray(global::System.Linq.Enumerable.Select(source.ImmutableArrayValue, x => ParseableInt(x)));
            target.ImmutableListValue = global::System.Collections.Immutable.ImmutableList.ToImmutableList(global::System.Linq.Enumerable.Select(source.ImmutableListValue, x => ParseableInt(x)));
            target.ImmutableHashSetValue = global::System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet(global::System.Linq.Enumerable.Select(source.ImmutableHashSetValue, x => ParseableInt(x)));
            target.ImmutableQueueValue = global::System.Collections.Immutable.ImmutableQueue.CreateRange(global::System.Linq.Enumerable.Select(source.ImmutableQueueValue, x => ParseableInt(x)));
            target.ImmutableStackValue = global::System.Collections.Immutable.ImmutableStack.CreateRange(global::System.Linq.Enumerable.Select(source.ImmutableStackValue, x => ParseableInt(x)));
            target.ImmutableSortedSetValue = global::System.Collections.Immutable.ImmutableSortedSet.ToImmutableSortedSet(global::System.Linq.Enumerable.Select(source.ImmutableSortedSetValue, x => ParseableInt(x)));
            target.ImmutableDictionaryValue = global::System.Collections.Immutable.ImmutableDictionary.ToImmutableDictionary(source.ImmutableDictionaryValue, x => ParseableInt(x.Key), x => ParseableInt(x.Value));
            target.ImmutableSortedDictionaryValue = global::System.Collections.Immutable.ImmutableSortedDictionary.ToImmutableSortedDictionary(source.ImmutableSortedDictionaryValue, x => ParseableInt(x.Key), x => ParseableInt(x.Value));
            foreach (var item in source.ExistingISet)
            {
                target.ExistingISet.Add(ParseableInt(item));
            }
            target.ExistingHashSet.EnsureCapacity(source.ExistingHashSet.Count + target.ExistingHashSet.Count);
            foreach (var item1 in source.ExistingHashSet)
            {
                target.ExistingHashSet.Add(ParseableInt(item1));
            }
            foreach (var item2 in source.ExistingSortedSet)
            {
                target.ExistingSortedSet.Add(ParseableInt(item2));
            }
            MapExistingList(source.ExistingList, target.ExistingList);
            target.ISet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(source.ISet, x => ParseableInt(x)));
            target.IReadOnlySet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(source.IReadOnlySet, x => ParseableInt(x)));
            target.HashSet = global::System.Linq.Enumerable.ToHashSet(global::System.Linq.Enumerable.Select(source.HashSet, x => ParseableInt(x)));
            target.SortedSet = new global::System.Collections.Generic.SortedSet<int>(global::System.Linq.Enumerable.Select(source.SortedSet, x => ParseableInt(x)));
            target.EnumValue = (global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue)source.EnumValue;
            target.FlagsEnumValue = (global::Riok.Mapperly.IntegrationTests.Dto.TestFlagsEnumDto)source.FlagsEnumValue;
            target.EnumName = MapToEnumDtoByName(source.EnumName);
            target.EnumRawValue = (byte)source.EnumRawValue;
            target.EnumStringValue = MapToString(source.EnumStringValue);
            target.EnumReverseStringValue = MapToTestEnumDtoByValue(source.EnumReverseStringValue);
            target.DateTimeValueTargetDateOnly = global::System.DateOnly.FromDateTime(source.DateTimeValueTargetDateOnly);
            target.DateTimeValueTargetTimeOnly = global::System.TimeOnly.FromDateTime(source.DateTimeValueTargetTimeOnly);
        }

        private static partial int PrivateDirectInt(int value)
        {
            return value;
        }

        public static partial object DerivedTypes(object source)
        {
            return source switch
            {
                string x => ParseableInt(x),
                int x => x.ToString(),
                _ => throw new System.ArgumentException($"Cannot map {source.GetType()} to object as there is no known derived type mapping", nameof(source)),
            };
        }

        public static partial object MapWithRuntimeTargetType(object source, global::System.Type targetType)
        {
            return source switch
            {
                global::Riok.Mapperly.IntegrationTests.Models.TestEnum x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName)) => MapToEnumDtoByName(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum)) => MapToEnumByNameWithExplicit(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum)) => MapToEnumByValueCheckDefined(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestFlagsEnumDto x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestFlagsEnum)) => MapToFlagsEnumByValueCheckDefined(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum)) => MapToEnumByNameWithFallback(x),
                int x when targetType.IsAssignableFrom(typeof(int)) => DirectInt(x),
                int x when targetType.IsAssignableFrom(typeof(long)) => ImplicitCastInt(x),
                uint x when targetType.IsAssignableFrom(typeof(int)) => ExplicitCastInt(x),
                global::System.DateTime x when targetType.IsAssignableFrom(typeof(global::System.DateTime)) => DirectDateTime(x),
                string x when targetType.IsAssignableFrom(typeof(global::System.Guid)) => ParseableGuid(x),
                string x when targetType.IsAssignableFrom(typeof(int)) => ParseableInt(x),
                global::Riok.Mapperly.IntegrationTests.Models.TestObject x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto)) => MapToDtoExt(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestObject)) => MapFromDto(x),
                global::System.Collections.Generic.IEnumerable<global::Riok.Mapperly.IntegrationTests.Models.TestObject> x when targetType.IsAssignableFrom(typeof(global::System.Collections.Generic.IEnumerable<global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto>)) => MapAllDtos(x),
                object x when targetType.IsAssignableFrom(typeof(object)) => DerivedTypes(x),
                null => throw new System.ArgumentNullException(nameof(source)),
                _ => throw new System.ArgumentException($"Cannot map {source.GetType()} to {targetType} as there is no known type mapping", nameof(source)),
            };
        }

        public static partial object? MapNullableWithRuntimeTargetType(object? source, global::System.Type targetType)
        {
            return source switch
            {
                global::Riok.Mapperly.IntegrationTests.Models.TestEnum x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName)) => MapToEnumDtoByName(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum)) => MapToEnumByNameWithExplicit(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum)) => MapToEnumByValueCheckDefined(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestFlagsEnumDto x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestFlagsEnum)) => MapToFlagsEnumByValueCheckDefined(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum)) => MapToEnumByNameWithFallback(x),
                int x when targetType.IsAssignableFrom(typeof(int)) => DirectInt(x),
                int x when targetType.IsAssignableFrom(typeof(long)) => ImplicitCastInt(x),
                uint x when targetType.IsAssignableFrom(typeof(int)) => ExplicitCastInt(x),
                global::System.DateTime x when targetType.IsAssignableFrom(typeof(global::System.DateTime)) => DirectDateTime(x),
                string x when targetType.IsAssignableFrom(typeof(global::System.Guid)) => ParseableGuid(x),
                string x when targetType.IsAssignableFrom(typeof(int)) => ParseableInt(x),
                global::Riok.Mapperly.IntegrationTests.Models.TestObject x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto)) => MapToDtoExt(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto x when targetType.IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestObject)) => MapFromDto(x),
                global::System.Collections.Generic.IEnumerable<global::Riok.Mapperly.IntegrationTests.Models.TestObject> x when targetType.IsAssignableFrom(typeof(global::System.Collections.Generic.IEnumerable<global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto>)) => MapAllDtos(x),
                object x when targetType.IsAssignableFrom(typeof(object)) => DerivedTypes(x),
                null => default,
                _ => throw new System.ArgumentException($"Cannot map {source.GetType()} to {targetType} as there is no known type mapping", nameof(source)),
            };
        }

        public static partial TTarget MapGeneric<TSource, TTarget>(TSource source)
        {
            return source switch
            {
                global::Riok.Mapperly.IntegrationTests.Models.TestEnum x when typeof(TTarget).IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName)) => (TTarget)(object)MapToEnumDtoByName(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue x when typeof(TTarget).IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum)) => (TTarget)(object)MapToEnumByNameWithExplicit(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue x when typeof(TTarget).IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum)) => (TTarget)(object)MapToEnumByValueCheckDefined(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestFlagsEnumDto x when typeof(TTarget).IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestFlagsEnum)) => (TTarget)(object)MapToFlagsEnumByValueCheckDefined(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName x when typeof(TTarget).IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum)) => (TTarget)(object)MapToEnumByNameWithFallback(x),
                int x when typeof(TTarget).IsAssignableFrom(typeof(int)) => (TTarget)(object)DirectInt(x),
                int x when typeof(TTarget).IsAssignableFrom(typeof(long)) => (TTarget)(object)ImplicitCastInt(x),
                uint x when typeof(TTarget).IsAssignableFrom(typeof(int)) => (TTarget)(object)ExplicitCastInt(x),
                global::System.DateTime x when typeof(TTarget).IsAssignableFrom(typeof(global::System.DateTime)) => (TTarget)(object)DirectDateTime(x),
                string x when typeof(TTarget).IsAssignableFrom(typeof(global::System.Guid)) => (TTarget)(object)ParseableGuid(x),
                string x when typeof(TTarget).IsAssignableFrom(typeof(int)) => (TTarget)(object)ParseableInt(x),
                global::Riok.Mapperly.IntegrationTests.Models.TestObject x when typeof(TTarget).IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto)) => (TTarget)(object)MapToDtoExt(x),
                global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto x when typeof(TTarget).IsAssignableFrom(typeof(global::Riok.Mapperly.IntegrationTests.Models.TestObject)) => (TTarget)(object)MapFromDto(x),
                global::System.Collections.Generic.IEnumerable<global::Riok.Mapperly.IntegrationTests.Models.TestObject> x when typeof(TTarget).IsAssignableFrom(typeof(global::System.Collections.Generic.IEnumerable<global::Riok.Mapperly.IntegrationTests.Dto.TestObjectDto>)) => (TTarget)(object)MapAllDtos(x),
                object x when typeof(TTarget).IsAssignableFrom(typeof(object)) => (TTarget)(object)DerivedTypes(x),
                null => throw new System.ArgumentNullException(nameof(source)),
                _ => throw new System.ArgumentException($"Cannot map {source.GetType()} to {typeof(TTarget)} as there is no known type mapping", nameof(source)),
            };
        }

        public static partial global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName MapToEnumDtoByName(global::Riok.Mapperly.IntegrationTests.Models.TestEnum v)
        {
            return v switch
            {
                global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10 => global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName.Value10,
                global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value20 => global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName.Value20,
                global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30 => global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName.Value30,
                _ => throw new System.ArgumentOutOfRangeException(nameof(v), v, "The value of enum TestEnum is not supported"),
            };
        }

        public static partial global::Riok.Mapperly.IntegrationTests.Models.TestEnum MapToEnumByNameWithExplicit(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue v)
        {
            return v switch
            {
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue.Value10 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10,
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue.Value20 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value20,
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue.Value30 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30,
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue.Value40 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30,
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue.Value50 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30,
                _ => throw new System.ArgumentOutOfRangeException(nameof(v), v, "The value of enum TestEnumDtoAdditionalValue is not supported"),
            };
        }

        public static partial global::Riok.Mapperly.IntegrationTests.Models.TestEnum MapToEnumByValueWithExplicit(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue v)
        {
            return v switch
            {
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue.Value40 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30,
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue.Value50 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30,
                _ => (global::Riok.Mapperly.IntegrationTests.Models.TestEnum)v,
            };
        }

        public static partial global::Riok.Mapperly.IntegrationTests.Models.TestEnum MapToEnumByNameWithIgnored(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue v)
        {
            return v switch
            {
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue.Value10 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10,
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoAdditionalValue.Value20 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value20,
                _ => throw new System.ArgumentOutOfRangeException(nameof(v), v, "The value of enum TestEnumDtoAdditionalValue is not supported"),
            };
        }

        public static partial global::Riok.Mapperly.IntegrationTests.Models.TestEnum MapToEnumByValueCheckDefined(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue v)
        {
            return (global::Riok.Mapperly.IntegrationTests.Models.TestEnum)v is global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10 or global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value20 or global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30 ? (global::Riok.Mapperly.IntegrationTests.Models.TestEnum)v : throw new System.ArgumentOutOfRangeException(nameof(v), v, "The value of enum TestEnumDtoByValue is not supported");
        }

        public static partial global::Riok.Mapperly.IntegrationTests.Models.TestEnum MapToEnumByValueCheckDefinedWithFallback(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue v)
        {
            return (global::Riok.Mapperly.IntegrationTests.Models.TestEnum)v is global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10 or global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value20 or global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30 ? (global::Riok.Mapperly.IntegrationTests.Models.TestEnum)v : global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10;
        }

        public static partial global::Riok.Mapperly.IntegrationTests.Models.TestFlagsEnum MapToFlagsEnumByValueCheckDefined(global::Riok.Mapperly.IntegrationTests.Dto.TestFlagsEnumDto v)
        {
            return (global::Riok.Mapperly.IntegrationTests.Models.TestFlagsEnum)v == ((global::Riok.Mapperly.IntegrationTests.Models.TestFlagsEnum)v & (global::Riok.Mapperly.IntegrationTests.Models.TestFlagsEnum.V1 | global::Riok.Mapperly.IntegrationTests.Models.TestFlagsEnum.V2 | global::Riok.Mapperly.IntegrationTests.Models.TestFlagsEnum.V4)) ? (global::Riok.Mapperly.IntegrationTests.Models.TestFlagsEnum)v : throw new System.ArgumentOutOfRangeException(nameof(v), v, "The value of enum TestFlagsEnumDto is not supported");
        }

        public static partial global::Riok.Mapperly.IntegrationTests.Models.TestEnum MapToEnumByNameWithFallback(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName v)
        {
            return v switch
            {
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName.Value10 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10,
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName.Value20 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value20,
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByName.Value30 => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30,
                _ => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10,
            };
        }

        private static global::Riok.Mapperly.IntegrationTests.Dto.TestObjectNestedDto MapToTestObjectNestedDto(global::Riok.Mapperly.IntegrationTests.Models.TestObjectNested source)
        {
            var target = new global::Riok.Mapperly.IntegrationTests.Dto.TestObjectNestedDto();
            target.IntValue = DirectInt(source.IntValue);
            return target;
        }

        private static (int A, int) MapToValueTuple((string A, string) source)
        {
            var target = (A: ParseableInt(source.A), ParseableInt(source.Item2));
            return target;
        }

        private static global::Riok.Mapperly.IntegrationTests.Dto.TestObjectNestedDto[] MapToTestObjectNestedDtoArray(global::System.Collections.Generic.IReadOnlyCollection<global::Riok.Mapperly.IntegrationTests.Models.TestObjectNested> source)
        {
            var target = new global::Riok.Mapperly.IntegrationTests.Dto.TestObjectNestedDto[source.Count];
            var i = 0;
            foreach (var item in source)
            {
                target[i] = MapToTestObjectNestedDto(item);
                i++;
            }
            return target;
        }

        private static int[] MapToInt32Array(global::System.Span<string> source)
        {
            var target = new int[source.Length];
            for (var i = 0; i < source.Length; i++)
            {
                target[i] = ParseableInt(source[i]);
            }
            return target;
        }

        private static int[] MapToInt32Array1(global::System.ReadOnlySpan<string> source)
        {
            var target = new int[source.Length];
            for (var i = 0; i < source.Length; i++)
            {
                target[i] = ParseableInt(source[i]);
            }
            return target;
        }

        private static string MapToString(global::Riok.Mapperly.IntegrationTests.Models.TestEnum source)
        {
            return source switch
            {
                global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10 => nameof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10),
                global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value20 => nameof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value20),
                global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30 => nameof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30),
                _ => source.ToString(),
            };
        }

        private static global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue MapToTestEnumDtoByValue(string source)
        {
            return source switch
            {
                nameof(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue1) => global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue1,
                nameof(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue2) => global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue2,
                nameof(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue3) => global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue3,
                _ => System.Enum.Parse<global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue>(source, false),
            };
        }

        private static global::Riok.Mapperly.IntegrationTests.Dto.InheritanceSubObjectDto MapToInheritanceSubObjectDto(global::Riok.Mapperly.IntegrationTests.Models.InheritanceSubObject source)
        {
            var target = new global::Riok.Mapperly.IntegrationTests.Dto.InheritanceSubObjectDto();
            target.SubIntValue = DirectInt(source.SubIntValue);
            target.BaseIntValue = DirectInt(source.BaseIntValue);
            return target;
        }

        private static global::Riok.Mapperly.IntegrationTests.Models.TestObjectNested MapToTestObjectNested(global::Riok.Mapperly.IntegrationTests.Dto.TestObjectNestedDto source)
        {
            var target = new global::Riok.Mapperly.IntegrationTests.Models.TestObjectNested();
            target.IntValue = DirectInt(source.IntValue);
            return target;
        }

        private static (string A, string) MapToValueTuple1((int A, int) source)
        {
            var target = (A: source.A.ToString(), source.Item2.ToString());
            return target;
        }

        private static global::System.Collections.Generic.IReadOnlyCollection<global::Riok.Mapperly.IntegrationTests.Models.TestObjectNested> MapToIReadOnlyCollection(global::Riok.Mapperly.IntegrationTests.Dto.TestObjectNestedDto[] source)
        {
            var target = new global::Riok.Mapperly.IntegrationTests.Models.TestObjectNested[source.Length];
            for (var i = 0; i < source.Length; i++)
            {
                target[i] = MapToTestObjectNested(source[i]);
            }
            return target;
        }

        private static string[] MapToStringArray(global::System.ReadOnlySpan<int> source)
        {
            var target = new string[source.Length];
            for (var i = 0; i < source.Length; i++)
            {
                target[i] = source[i].ToString();
            }
            return target;
        }

        private static global::Riok.Mapperly.IntegrationTests.Models.TestEnum MapToTestEnum(string source)
        {
            return source switch
            {
                nameof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10) => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value10,
                nameof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value20) => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value20,
                nameof(global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30) => global::Riok.Mapperly.IntegrationTests.Models.TestEnum.Value30,
                _ => System.Enum.Parse<global::Riok.Mapperly.IntegrationTests.Models.TestEnum>(source, false),
            };
        }

        private static string MapToString1(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue source)
        {
            return source switch
            {
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue1 => nameof(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue1),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue2 => nameof(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue2),
                global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue3 => nameof(global::Riok.Mapperly.IntegrationTests.Dto.TestEnumDtoByValue.DtoValue3),
                _ => source.ToString(),
            };
        }

        private static global::Riok.Mapperly.IntegrationTests.Models.InheritanceSubObject MapToInheritanceSubObject(global::Riok.Mapperly.IntegrationTests.Dto.InheritanceSubObjectDto source)
        {
            var target = new global::Riok.Mapperly.IntegrationTests.Models.InheritanceSubObject();
            target.SubIntValue = DirectInt(source.SubIntValue);
            target.BaseIntValue = DirectInt(source.BaseIntValue);
            return target;
        }
    }
}
